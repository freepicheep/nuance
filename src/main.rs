mod checksum;
mod cli;
mod config;
mod error;
mod git;
mod installer;
mod lockfile;
mod manifest;
mod resolver;

use std::path::Path;

use cli::Commands;
use config::GlobalConfig;
use error::Result;
use manifest::{DependencySpec, Manifest, Package};

fn main() {
    let cli = cli::parse();

    if let Err(e) = run(cli.command) {
        eprintln!("error: {e}");
        std::process::exit(1);
    }
}

fn run(command: Commands) -> Result<()> {
    let cwd = std::env::current_dir()?;

    match command {
        Commands::Init {
            name,
            version,
            description,
        } => cmd_init(&cwd, name, version, description),
        Commands::Install { global, frozen } => {
            if global {
                cmd_install_global(frozen)
            } else {
                cmd_install(&cwd, frozen)
            }
        }
        Commands::Update => cmd_update(&cwd),
        Commands::Add {
            global,
            url,
            tag,
            rev,
            branch,
        } => {
            if global {
                cmd_add_global(url, tag, rev, branch)
            } else {
                cmd_add(&cwd, url, tag, rev, branch)
            }
        }
        Commands::Remove { global, name } => {
            if global {
                cmd_remove_global(name)
            } else {
                cmd_remove(&cwd, name)
            }
        }
        Commands::Hook => cmd_hook(),
    }
}

fn cmd_init(
    dir: &Path,
    name: Option<String>,
    version: String,
    description: Option<String>,
) -> Result<()> {
    let mod_toml = dir.join("mod.toml");
    if mod_toml.exists() {
        return Err(error::NuanceError::Manifest(
            "mod.toml already exists in this directory".to_string(),
        ));
    }

    // Default name to directory name
    let pkg_name = name.unwrap_or_else(|| {
        dir.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("my-module")
            .to_string()
    });

    let manifest = Manifest {
        package: Package {
            name: pkg_name.clone(),
            version,
            description,
            license: None,
            authors: None,
            nu_version: None,
        },
        dependencies: Default::default(),
    };

    let content = manifest.to_toml_string()?;
    std::fs::write(&mod_toml, content)?;
    eprintln!("Created mod.toml for '{pkg_name}'");

    // Also create mod.nu if it doesn't exist
    let mod_nu = dir.join("mod.nu");
    if !mod_nu.exists() {
        std::fs::write(
            &mod_nu,
            "# Module entry point\n# Export your commands here with: export use <submodule>\n",
        )?;
        eprintln!("Created mod.nu");
    }

    Ok(())
}

fn cmd_install(dir: &Path, frozen: bool) -> Result<()> {
    installer::install(dir, frozen)
}

fn cmd_install_global(frozen: bool) -> Result<()> {
    installer::install_global(frozen)
}

fn cmd_update(dir: &Path) -> Result<()> {
    installer::update(dir)
}

fn cmd_add(
    dir: &Path,
    url: String,
    tag: Option<String>,
    rev: Option<String>,
    branch: Option<String>,
) -> Result<()> {
    // Load existing manifest (or error if none)
    let mut manifest = Manifest::from_dir(dir)?;
    let provider_base = if is_git_url(url.trim()) {
        None
    } else {
        let config = GlobalConfig::load_or_default()?;
        Some(config.default_git_provider_base_url()?)
    };
    let url = normalize_dependency_source(&url, provider_base.as_deref())?;

    // Derive package name from URL
    let pkg_name = git::repo_name_from_url(&url).ok_or_else(|| {
        error::NuanceError::Other(format!("could not determine package name from URL: {url}"))
    })?;

    // Check if already added
    if manifest.dependencies.contains_key(&pkg_name) {
        return Err(error::NuanceError::Manifest(format!(
            "dependency '{pkg_name}' already exists in mod.toml"
        )));
    }

    // If no ref spec given, auto-detect: try latest tag, fall back to default branch
    let dep_spec = auto_detect_dep_spec(&url, tag, rev, branch)?;

    dep_spec.validate(&pkg_name)?;

    // Add to manifest and write back
    manifest.dependencies.insert(pkg_name.clone(), dep_spec);
    let content = manifest.to_toml_string()?;
    std::fs::write(dir.join("mod.toml"), content)?;

    eprintln!("Added '{pkg_name}' to mod.toml");

    // Run install
    installer::install(dir, false)
}

fn cmd_add_global(
    url: String,
    tag: Option<String>,
    rev: Option<String>,
    branch: Option<String>,
) -> Result<()> {
    let mut config = GlobalConfig::load()?;
    let provider_base = if is_git_url(url.trim()) {
        None
    } else {
        Some(config.default_git_provider_base_url()?)
    };
    let url = normalize_dependency_source(&url, provider_base.as_deref())?;

    // Derive package name from URL
    let pkg_name = git::repo_name_from_url(&url).ok_or_else(|| {
        error::NuanceError::Other(format!("could not determine package name from URL: {url}"))
    })?;

    // Check if already added
    if config.dependencies.contains_key(&pkg_name) {
        return Err(error::NuanceError::Config(format!(
            "dependency '{pkg_name}' already exists in global config"
        )));
    }

    let dep_spec = auto_detect_dep_spec(&url, tag, rev, branch)?;

    dep_spec.validate(&pkg_name)?;

    // Add to global config and save
    config.dependencies.insert(pkg_name.clone(), dep_spec);
    config.save()?;

    eprintln!("Added '{pkg_name}' to global config");

    // Run global install
    installer::install_global(false)
}

fn cmd_remove(dir: &Path, name: String) -> Result<()> {
    // Load existing manifest
    let mut manifest = Manifest::from_dir(dir)?;

    // Check the dep exists
    if manifest.dependencies.remove(&name).is_none() {
        return Err(error::NuanceError::Manifest(format!(
            "dependency '{name}' not found in mod.toml"
        )));
    }

    // Write updated manifest
    let content = manifest.to_toml_string()?;
    std::fs::write(dir.join("mod.toml"), content)?;
    eprintln!("Removed '{name}' from mod.toml");

    // Remove from .nu_modules/
    let module_dir = dir.join(".nu_modules").join(&name);
    if module_dir.exists() {
        std::fs::remove_dir_all(&module_dir)?;
        eprintln!("Removed .nu_modules/{name}/");
    }

    // Update lockfile: remove the package entry
    let lock_path = dir.join("mod.lock");
    if lock_path.exists() {
        let mut lockfile = lockfile::Lockfile::from_path(&lock_path)?;
        lockfile.packages.retain(|p| p.name != name);
        lockfile.write_to(&lock_path)?;
        eprintln!("Updated mod.lock");
    }

    // Regenerate activate.nu from the updated manifest and lockfile state.
    eprintln!("Regenerating activate.nu...");
    installer::install(dir, false)?;

    Ok(())
}

fn cmd_remove_global(name: String) -> Result<()> {
    let mut config = GlobalConfig::load()?;

    // Check the dep exists
    if config.dependencies.remove(&name).is_none() {
        return Err(error::NuanceError::Config(format!(
            "dependency '{name}' not found in global config"
        )));
    }

    // Save updated config
    config.save()?;
    eprintln!("Removed '{name}' from global config");

    // Remove from global modules dir
    let modules_dir = config.modules_dir()?;
    let module_dir = modules_dir.join(&name);
    if module_dir.exists() {
        std::fs::remove_dir_all(&module_dir)?;
        eprintln!("Removed {}/", module_dir.display());
    }

    // Update global lockfile
    let lock_path = config::global_lock_path()?;
    if lock_path.exists() {
        let mut lockfile = lockfile::Lockfile::from_path(&lock_path)?;
        lockfile.packages.retain(|p| p.name != name);
        lockfile.write_to(&lock_path)?;
        eprintln!("Updated global lockfile");
    }

    // Regenerate the activate.nu overlay with remaining global packages
    eprintln!("Regenerating global activate.nu...");
    installer::install_global(false)?;

    Ok(())
}

fn cmd_hook() -> Result<()> {
    let hook_script = r#"# nuance auto-activate hook â€” add this to your config.nu (or env.nu)
$env.config.hooks.env_change.PWD = (
    $env.config.hooks.env_change.PWD | default [] | append {|before, after|
        # Remove previous directory's modules if it was a nuance project
        if ($before | path join "mod.toml" | path exists) {
            let old_modules = ($before | path join ".nu_modules")
            $env.NU_LIB_DIRS = ($env.NU_LIB_DIRS | default [] | where { |it| $it != $old_modules })
        }
        # Add new directory's modules if it is a nuance project
        if ($after | path join "mod.toml" | path exists) {
            let new_modules = ($after | path join ".nu_modules")
            if ($new_modules | path exists) and ($new_modules not-in ($env.NU_LIB_DIRS | default [])) {
                $env.NU_LIB_DIRS = ($env.NU_LIB_DIRS | default [] | append $new_modules)
            }
        }
    }
)"#;
    println!("{hook_script}");
    Ok(())
}

fn normalize_dependency_source(input: &str, provider_base_url: Option<&str>) -> Result<String> {
    let trimmed = input.trim();

    if trimmed.is_empty() {
        return Err(error::NuanceError::Other(
            "dependency source cannot be empty".to_string(),
        ));
    }

    if is_git_url(trimmed) {
        return Ok(trimmed.to_string());
    }

    if is_repo_shorthand(trimmed) {
        let provider_base = provider_base_url.ok_or_else(|| {
            error::NuanceError::Other(
                "a default git provider is required for owner/repo shorthand".to_string(),
            )
        })?;
        return Ok(format!("{provider_base}/{trimmed}"));
    }

    Err(error::NuanceError::Other(format!(
        "invalid dependency source '{input}'; expected a git URL or owner/repo shorthand"
    )))
}

fn is_git_url(value: &str) -> bool {
    value.contains("://") || value.starts_with("git@")
}

fn is_repo_shorthand(value: &str) -> bool {
    let mut parts = value.split('/');
    let owner = parts.next().unwrap_or_default();
    let repo = parts.next().unwrap_or_default();

    parts.next().is_none()
        && !owner.is_empty()
        && !repo.is_empty()
        && !owner.chars().any(char::is_whitespace)
        && !repo.chars().any(char::is_whitespace)
}

/// Auto-detect the dependency spec from a URL, optionally with an explicit ref.
///
/// If no tag/rev/branch is given, tries the latest tag first, then falls back
/// to the default branch.
fn auto_detect_dep_spec(
    url: &str,
    tag: Option<String>,
    rev: Option<String>,
    branch: Option<String>,
) -> Result<DependencySpec> {
    if tag.is_none() && rev.is_none() && branch.is_none() {
        eprintln!("Fetching {url} to detect version...");
        let repo_path = git::clone_or_fetch(url)?;

        if let Some(latest) = git::latest_tag(&repo_path)? {
            eprintln!("  Found latest tag: {latest}");
            Ok(DependencySpec {
                git: url.to_string(),
                tag: Some(latest),
                rev: None,
                branch: None,
            })
        } else {
            let default_br = git::default_branch(&repo_path)?;
            eprintln!("  No tags found, using branch: {default_br}");
            Ok(DependencySpec {
                git: url.to_string(),
                tag: None,
                rev: None,
                branch: Some(default_br),
            })
        }
    } else {
        Ok(DependencySpec {
            git: url.to_string(),
            tag,
            rev,
            branch,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    fn config_with_provider(provider: &str) -> GlobalConfig {
        GlobalConfig {
            modules_dir: None,
            default_git_provider: provider.to_string(),
            dependencies: HashMap::new(),
        }
    }

    #[test]
    fn normalize_dependency_source_passes_through_urls() {
        let https = normalize_dependency_source("https://example.com/team/repo", None).unwrap();
        assert_eq!(https, "https://example.com/team/repo");

        let ssh = normalize_dependency_source("git@github.com:user/repo.git", None).unwrap();
        assert_eq!(ssh, "git@github.com:user/repo.git");
    }

    #[test]
    fn normalize_dependency_source_expands_repo_shorthand() {
        let config = config_with_provider("github");
        let provider = config.default_git_provider_base_url().unwrap();
        let expanded =
            normalize_dependency_source("freepicheep/nu-salesforce", Some(provider.as_str()))
                .unwrap();
        assert_eq!(expanded, "https://github.com/freepicheep/nu-salesforce");
    }

    #[test]
    fn normalize_dependency_source_uses_custom_provider() {
        let config = config_with_provider("gitlab");
        let provider = config.default_git_provider_base_url().unwrap();
        let expanded = normalize_dependency_source("group/repo", Some(provider.as_str())).unwrap();
        assert_eq!(expanded, "https://gitlab.com/group/repo");
    }

    #[test]
    fn normalize_dependency_source_rejects_invalid_input() {
        let err = normalize_dependency_source("just-a-repo", None).unwrap_err();
        assert!(err.to_string().contains("owner/repo shorthand"));
    }

    #[test]
    fn normalize_dependency_source_requires_provider_for_shorthand() {
        let err = normalize_dependency_source("owner/repo", None).unwrap_err();
        assert!(err.to_string().contains("default git provider"));
    }
}
